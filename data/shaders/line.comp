// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

#extension GL_GOOGLE_include_directive : enable
#include "noise.glslinc"
#include "utils.glslinc"

layout(local_size_x_id = 0) in;

// The MAX_GROUP_SIZE_X value is overwritten on pipeline creation
layout(constant_id = 0) const uint MAX_GROUP_SIZE_X = 32;

// Storage
layout(std430) restrict writeonly buffer OutPositions
{
	vec4 outpositions[];
};

layout(std430) restrict writeonly buffer OutColors
{
	vec4 outcolors[];
};

layout(std430) restrict readonly buffer InPositions
{
	vec4 inpositions[];
};

layout(std430) restrict readonly buffer InNormals
{
	vec4 innormals[];
};

layout(std430) restrict readonly buffer InUVs
{
	vec4 inuvs[];
};

layout(std430) restrict readonly buffer InColors
{
	vec4 incolors[];
};

uniform UBO
{
	float elapsedTime;
	float wavelength;
	float amplitude;
	float offset;
	float shift;
	float timeshift;
	float alpha;
	vec4 colorOne;
	vec4 colorTwo;
	uint count;
} ubo;

// uint rgba8(vec4 col, float alpha)
// {
// 	col = clamp(col, 0.0, 1.0);
// 	return (
// 		(uint(col.r*255.0) & 0xff) << 24 |
// 		(uint(col.g*255.0) & 0xff) << 16 |
// 		(uint(col.b*255.0) & 0xff) << 8  |
// 		(uint(col.a*255.0) & 0xff)
// 	);
// }

const float PI2 = PI*2.0;
const float HURST_EXP = 0.45; // [0,1] from rough to smooth
const uint OCTAVES = 6;


vec3 gerstner(float x, float t, float steep, float wavelen)
{
	float k = PI2/max(wavelen, 0.001); // magnitude
	float w = k * x - t;
	float f = fract(w/PI2)*PI2; // Stabilize w before feeding into trig funcs
	float a = steep/k;

	// We do not require the tangent/deivative
	// outTangent = vec3(1.0-steepness*sin(f), steepness * cos(f), 0.0);
	return vec3(cos(f)*a, sin(f)*a, cos(f)*a);
}


vec3 wave(float x, float t, float steep, float wavelen, float timeshift)
{
	const float s = steep*(1.0/float(OCTAVES));

	// https://iquilezles.org/articles/fbm/
	const float G = exp2(-HURST_EXP);
	float f = 1.0;
	float a = 1.0;
	vec3 w = vec3(0.0);
	for (uint i=0; i<OCTAVES; i++)
	{
		w += a*gerstner(f*x, t, s, wavelen);
		f *= 2.0;
		a *= G;
		t *= timeshift;
	}
	return w;
}


void main()
{
	const uint gid = gl_GlobalInvocationID.x;
	const vec2 uv = vec2(inuvs[gid].x, inuvs[gid].y);
	const float t = ubo.elapsedTime + ubo.offset;

	const float steepness = clamp(ubo.amplitude, 0.0, 1.0);
	const vec2 shift = { ubo.shift*ubo.wavelength*0.5, 0.0 };

	// uv shifted
	const vec2 uvs = (uv + shift) - 0.5;
	const vec3 w = wave(uvs.x, t, steepness, ubo.wavelength, ubo.timeshift);
	const vec4 p = inpositions[gid];
	outpositions[gid] = p + vec4(w, 1.0);

	// Still figuring out how to make this look good on the laser
	// const float pct = clamp((w.y*20.0+ubo.amplitude)/max(ubo.amplitude*2.0, 0.001), 0.0, 1.0);
	// const float pct = pow(1.0-abs(clamp(uv.x*2.0-0.5, 0.0, 1.0)), 2.0);
	// const vec4 col = mix(ubo.colorOne, ubo.colorTwo, pct);
	const vec4 col = ubo.colorOne;
	outcolors[gid] = vec4(col.rgb, pow(ubo.alpha, 3.0));
}
